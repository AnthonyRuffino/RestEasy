<!DOCTYPE html>
<html lang="en" ng-app>
<head>
<title>RestEasy</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/x-icon" href="/img/favicon.ico?version=1">
<link rel="stylesheet" href="/css/site.css">
<link rel="stylesheet" href="/css/bootstrap.min.css">
<link rel="stylesheet" href="/css/bootstrap-responsive.min.css">
</head>
<body>
	<div class="container">
		<div class="navbar navbar-fixed-top navbar-inverse">
			<div class="navbar-inner">
				<div class="pull-right">
					<a href="/" class="brand">RestEasy</a>
				</div>
			</div>
		</div>
		<div class="page-header">
			<h1>RestEasy</h1>
		</div>
		<div class="row">
			<div class="span3">
				<img src="/img/restEasy.png" alt="RestEasy" height="100" width="100">
			</div>
		</div>
		<br /> <br />
		<div class="row header-row">
			<h2>
				<a href="https://tools.ietf.org/html/rfc2616" target="#">HTTP
					Standards</a> in RESTful Web Applications
			</h2>
		</div>
		<div class="row text-row">The purpose of this presentation is to
			review some common principals of the HTTP standard, and namely, how
			they can be leveraged in order to make our RESTful web applications
			faster and more efficient.</div>
		<div class="row text-row">This application also contains a
			RESTful web application written with Spring-boot which can be used in
			order to demonstrate some of the concepts discussed.</div>
		<div class="row text-row">The RESTful demo uses the idea of a
			simple project with a name and an owner. We will also reference this
			concept in discussion. We will occasionally pretend that the project
			model is more complex (e.g. imagine if it had related tasks, ect.)
			but the project model in the actual demo does not contain any of the
			more complex representations.</div>


		<div class="row header-row">
			<ul class="nav nav-list well">
				<li class="nav-header">Index</li>
				<li>1 - <a href="#theBigPicture" style="display: inline;">The
						Big Picture</a>
					<ul>
						<li><a href="#httpHeaders">HTTP Headers</a></li>
						<li><a href="#headMethod">HEAD method</a></li>
					</ul>
				</li>
				<li>2 - <a href="#postVsPut" style="display: inline;">Creating
						and Updating - POST versus PUT</a></li>
				<li>3 - <a href="#safeAndIdemotent" style="display: inline;">Safe
						and Idempotent Methods</a></li>
			</ul>
		</div>


		<br /> <br />
		<div class="row">
			<img src="/img/httpDecisionTree.png" alt="Http Decision Tree"
				height="500" width="500">
		</div>

		<div class="row header-row">
			<h3 id="theBigPicture">The Big Picture</h3>
		</div>

		<div class="row text-row">The above diagram is the entire HTTP
			decision tree which we will reference throughout this demonstration.
			We will zoom into individual sections of the image in order to
			discuss them in more detail. Before we do so, let's discuss the
			figurative "Big Picture".</div>
		<div class="row text-row">
			<ul>
				<li>The first thing to ask is <b>Why?</b> Why should we follow
					these standards and do we get out of it? The answer is simple:
					speed and efficiency.</a>
				</li>
				<li>A more complicated question is <b>How?</b> What is the
					mechanism for for getting these benefits? In short, the answer is
					the HEAD method and HTTP headers. Let's discuss this in more detail
					below.</a>
				</li>
			</ul>
		</div>

		<div class="row header-row">
			<h4 id="httpHeaders">HTTP Headers</h4>
		</div>
		<div class="row text-row">Both the client and the server need to
			work with various HTTP headers in order to leverage the standard.
			Some are controlled on the client side and considered on the server
			while some are controlled on the server and consider by the client
			side code.</div>

		<div class="row text-row">
			<ul class="nav nav-list well">
				<li class="nav-header">Server Side</li>
				<li>1 - <b>ETag</b>: A hash of the current state of the data
					involved with resource )
					<ul>
						<li>Server should avoid recalculating this value. (i.e. it
							should be persisted)</li>
						<li>Might require multiple representations per entity (i.e.
							request for a project with or without project tasks)</li>
						<li>Not practical for end-points which return lists of
							resources (i.e. How should we calculate the ETag for a list
							projects?) Tip: returning the ETag of the last modified project
							does not always work unless the last modified date is part of the
							ETag hash (which is problematic in itself).)</li>
					</ul>
				</li>
				<li>2 - <b>Last-Modified</b>: The date that a resource was last
					modified
					<ul>
						<li>Server should persist this value</li>
						<li>Might require multiple representations per entity (i.e.
							request for a project with or without project tasks)</li>
						<li>Much better suited than ETags for requests for lists of
							resources</li>
					</ul>
				</li>
			</ul>
		</div>


		<div class="row text-row">
			<ul class="nav nav-list well">
				<li class="nav-header">Client Side (Preconditions)</li>
				<li>1 - <b>If-Match</b>
					<ul>
						<li>The value should be a previously returned ETag for the
							given resource.</li>
						<li>If the resource on the server currently does not match
							the provided ETag then the <b>412-Preconditioned Failed</b>
							response code would be returned by the server.
						</li>
						<li>Should work with HEAD, GET, PUT, DELETE and POST<a
							href="#avoidingPOSTWithExisingResources">*</a>.
						</li>
					</ul>
				</li>
				<li>2 - <b>If-None-Match</b>
					<ul>
						<li>The value should be a previously returned ETag for the
							given resource.</li>
						<li>If the resource on the server currently does match the
							provided ETag then the <b>412-Preconditioned Failed</b> response
							code should be returned by the server.
						</li>
						<li>Should work with HEAD, GET, PUT, DELETE and POST<a
							href="#avoidingPOSTWithExisingResources">*</a>.
						</li>
					</ul>
				</li>
				<li>3 - <b>If-Unmodified-Since</b>
					<ul>
						<li>The value should be <a
							href="https://tools.ietf.org/html/rfc2616#section-14.29"
							target="#">properly formatted date</a>.
						</li>
						<li>If the resource on the server has been modified after the
							the provided date then the <b>412-Preconditioned Failed</b>
							response code should be returned by the server.
						</li>
						<li>Should work with HEAD, GET, PUT, DELETE and POST<a
							href="#avoidingPOSTWithExisingResources">*</a>.
						</li>
					</ul>
				</li>
				<li>3 - <b>If-Unmodified-Since</b>
					<ul>
						<li>The value should be properly formatted date.</a></li>
						<li>If the resource on the server has been not been modified
							after the the provided date then the <b>412-Preconditioned
								Failed</b> response code should be returned by the server.
						</li>
						<li>Should work with HEAD, GET, PUT, DELETE and POST<a
							href="#avoidingPOSTWithExisingResources">*</a>.
						</li>
					</ul>
				</li>
			</ul>
		</div>


		<div class="row header-row">
			<h4 id="headMethod">HEAD Method</h4>
		</div>
		<div class="row text-row">The above headers can all work in
			conjunction with the HTTP HEAD method. The HTTP HEAD method is
			intended to undergo the same server side processing as a GET request,
			but it ultimately does not return a response body. It should consider
			all of the client side headers discussed above and return the server
			side header exactly as it would for a similar GET request. This is a
			great mechanism for retrieving meta data about a resource without
			unnecessarily burdening our internal networks as well as the the data
			plans of our users.</div>


		<div class="row header-row">
			<h3 id="postVsPut">Creating and Updating - POST versus PUT</h3>
		</div>

		<img src="/img/postVsPut.png" alt="putVsPut"  width="600">

		<div class="row text-row" id="avoidingPOSTWithExisingResources">Technically
			speaking the HTTP standard allows for using both POST and PUT for
			both creating and updating a resource. There is far too much nuance
			involved when you allow this, and I highly recommend only allowing
			POST for creating and PUT for updates. There are certainly benefits
			to allowing both operations to be achieved via both methods, but the
			level of complexity it brings to your API is usually not worth it.</div>
		<div class="row text-row">
			Additionally, the JSON Merge Patch format was introduced in <a
				href="https://tools.ietf.org/html/rfc7396">RFC-7396</a>. This is
			also add a layer of complexity, but if you really require granular
			updates to portions of resources, this is likely a better approach. I
			do not cover the PATCH method in this demonstration, and in absence
			of supporting PATCH, I recommend that your API provide more granular
			end-points to achieve this functionality (g.e. PUT
			/projects/updateOwner).
		</div>


		<div class="row header-row" id="safeAndIdemotent">
			<h3 id="postVsPut">Safe and Idempotent Methods</h3>
		</div>

		<img src="/img/safety.jpg" alt="Idempotent" width="100" style="padding-top:20px;">

		<div class="row text-row"><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1" target="#">Section 9.1.1</a> 
		of the standard describes the convention of "safe methods" perfectly and concisely with the following: 
		The convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an 
		action other than retrieval. These methods ought to be considered "safe". This allows user agents to represent 
		other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact 
		that a possibly unsafe action is being requested.</div>
		
		
		<img src="/img/idempotent.jpg" alt="Idempotent" width="400" style="padding-top:20px;">
		
		<div class="row text-row">
			<b>Idempotent</b>: <i>denoting an element of a set which is unchanged in value when multiplied or otherwise operated on by itself.</i>
		</div>
		
		<div class="row text-row">
			The above image, though funny in a "Yes I am a geek" sort of a way, is a bit misleading as to the nature of idempotency.
			While it is true that the GET method is idempotent, that does not mean it ill always return the same value.  It is idempotent, because 
			the state of the resource on the server will be the same no matter how many times the GET request is performed.  This is naturally true for GET
			requests because they do not change the state of the resource; they are safe.
		</div>
		
		<div class="row text-row">
			Perhaps more interestingly, there are unsafe methds (PUT and DELETE) which are also idempotent.  This means that 
			a client application can perform these operations multiple times without worrying about unintended consequences.
		</div>


		<div class="row">
			<div class="span3">
				<br /> OPTIONS /project <br /> <br /> POST
				/project?name=Test1&owner=Me <br /> <br /> PUT
				/project?id=1,name=Test1-1 <br />[If-Match, If-None-Match,
				If-Unmodified-Since, If-Modified-Since] <br /> <br /> DELETE
				/project?id=1 <br />[If-Match, If-None-Match, If-Unmodified-Since,
				If-Modified-Since] <br /> <br /> HEAD /project/1 <br />[If-Match,
				If-Unmodified-Since, If-Modified-Since] <br /> <br /> GET
				/project/1 <br />[If-Match, If-Unmodified-Since, If-Modified-Since]
				<br /> <br />
			</div>
		</div>
	</div>
</body>
</html>
